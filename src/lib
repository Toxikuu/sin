#!/bin/sh
# Library for sin
# Much of this is stolen from KISS's init

SIN_LOG_FILE=/var/log/sin.log

log() {
    msg="$1"; shift
    printf " [\033[0;35m*\033[0;0m] " # decor
    printf "%s\n" "$msg"
    log_content="$log_content
$msg"
}

flush_log() {
    printf "%s" "$log_content" >> "$SIN_LOG_FILE"
    unset log_content
}

clear_log() {
    :>"$SIN_LOG_FILE"
}

mounted() {
    [ -e "$1" ]         || return 1
    [ -e /proc/mounts ] || return 1

    while read -r _ target _; do
        [ "$target" = "$1" ] && return 0
    done < /proc/mounts

    return 1
}

mnt() {
    mounted "$4" && set -- "remount,$1" "$2" "$3" "$4"
    mount -o "$1" -t "$2" "$3" "$4"
}

sos() {
    log "Sin encountered an error; starting emergency shell"
    log "When ready, type 'exit' to continue the boot"

    /bin/sh
}

die() {
    log "$1" >&2
    exit "${2:-1}"
}

# minimal implementation of sysvinit/ubase killall5
# $1 is the signal to send, defaulting to -TERM if unset
killall5() {
    curr_sid=$(awk "\$1 == $$ { print \$6 }")

    for pid in /proc/[0-9]*; do
        pid="${pid#/proc/}"

        # skip self
        [ "$pid" -eq "$$" ] && continue

        # get process's sid
        sid=$(awk '{ print $6 }' "/proc/$pid/stat" 2>/dev/null) || continue

        # skip if our sid
        [ "$sid" -eq "$curr_sid" ] && continue

        kill "${1:--TERM}" "$pid" 2>/dev/null
    done
}
