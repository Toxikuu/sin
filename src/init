#!/bin/sh
# This simple, POSIX-compliant init is part of sin
# With love, by Tox

. /etc/sin/lib

export TERM=linux
export PATH="/usr/bin:/usr/sbin"

# Tell dmesg to stfu and not overwrite our logs
dmesg -n 1

# Banner

clear
printf " ================================\n"
printf "  \033[1;34m*\033[0m Sin v|VERSION| initiating boot \033[1;34m*\033[0m\n"
printf " ================================\n\n"

# File system

log "Mounting pseudo file systems"

mnt nosuid,noexec,nodev    proc     proc /proc
mnt nosuid,noexec,nodev    sysfs    sys  /sys
mnt mode=0755,nosuid       devtmpfs dev  /dev
mnt mode=0755,nosuid,nodev tmpfs    run  /run

mkdir -pv /run/user /run/lock /run/log /dev/pts /dev/shm

mnt mode=0620,gid=5,nosuid,noexec devpts devpts /dev/pts
mnt mode=1777,nosuid,nodev        tmpfs  shm    /dev/shm

ln -sv /proc/self/fd /dev/fd
ln -sv fd/0 /dev/stdin
ln -sv fd/1 /dev/stdout
ln -sv fd/2 /dev/stderr

log "Checking file systems"
fsck -pACTV || sos

log "Remounting rootfs as rw"
mount -vo remount,rw / || sos

log "Mounting all local filesystems"
mount -va || sos

rm -f /halt
clear_log
flush_log

# Network

log "Setting up loopback interface"
ip link set lo up

log "Setting hostname"
read -r hostname < /etc/hostname
printf %s "${hostname:-lfs}" > /proc/sys/kernel/hostname

# Finalize

upt=$(awk '{print $1}' /proc/uptime)
log "Booted in $upt seconds"
flush_log

# Services

log "Running default services"
while IFS= read -r line; do
    # Trim whitespace
    # Stolen from https://web.archive.org/web/20121022051228/http://codesnippets.joyent.com/posts/show/1816
    line="${line#"${line%%[![:space:]]*}"}"
    line="${line%"${line##*[![:space:]]}"}"

    # Skip comments and empty lines
    case "$line" in
        ''|\#*) continue ;;
    esac

    run -s "$line"
    log "Starting $line"
done < /etc/sin/sv/DEFAULT

flush_log


do_halt() {

# Kill everything

log "Terminating and killing all processes"
killall5 -TERM
sleep 1
killall5 -KILL
# for pid in $(ps -eo pid | tail -n +2); do [ "$pid" != "$$" ] && [ "$pid" != "1" ] && kill -TERM "$pid"; done
# sleep 1
# for pid in $(ps -eo pid | tail -n +2); do [ "$pid" != "$$" ] && [ "$pid" != "1" ] && kill -KILL "$pid"; done

# Cleanup

log "Cleaning /tmp"
find /tmp -mindepth 1 -delete

flush_log

# File system

log "Unmounting filesystems"
umount -rat nosysfs,noproc,nodevtmpfs,tmpfs

log "Remounting rootfs as ro"
mount -o ro,remount /

# Shutdown

echo 1 > /proc/sys/kernel/sysrq
HALT="$(cat /halt)"

log "Evaluating final case statement"
case "$HALT" in
    shutdown)
        log "Telling kernel to shutdown"
        sync
        echo o > /proc/sysrq-trigger
        ;;
    reboot)
        log "Telling kernel to reboot"
        sync
        echo b > /proc/sysrq-trigger
        ;;
    *)
        log "Unknown HALT value: $HALT"
        log "Going with reboot"
        sync
        echo b > /proc/sysrq-trigger
        ;;
esac

# TODO: Remove this once I conclude it's unnecessary
log "Went past final case statement"
sync
sleep 10
log "You shouldn't see this"
sync

}


# Pause indefinitely until TERM is received, at which point we halt
trap 'echo "Received TERM"; do_halt' TERM
pause &
wait $!
